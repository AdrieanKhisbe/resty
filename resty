#
# resty - A tiny command line REST interface for bash and zsh.
#
# Fork me on github:
#   http://github.com/micha/resty
#
# Author:
#   Micha Niskin <micha@thinkminimo.com>
#   Copyright 2009, no rights reserved.
#
# Maintener:
#   Adriean Khisbe <adriean.khisbe@live.fr>
#


export _resty_host="" # TODO: to upper case!
export _resty_path=""
export _resty_nohistory=""


# TODO: global var holers
export _RESTY_DATA_DIR _RESTY_CONF_DIR;


function resty() {

    if [ -n "$XDG_CONFIG_HOME" ]; then
	_RESTY_CONF_DIR="$XDG_CONFIG_HOME/resty"
	_RESTY_DATA_DIR="$XDG_DATA_HOME/resty"
    else
	_RESTY_CONF_DIR="$HOME/.resty"
	_RESTY_DATA_DIR="$_RESTY_CONF_DIR"
    fi
    mkdir -p "$_RESTY_CONF_DIR"

    local host="$_RESTY_DATA_DIR/host"

    local url=$1

    case "$url" in
	http://*|https://*)
	    _resty_opts=$(printf '%q ' "${curlopt[@]}")
	    export _resty_opts
	    echo "$url" |grep '\*' >/dev/null || url="${url}*"
	    (echo "$url" |tee "${_resty_nohistory:-$host}") |cat 1>&2 \
		&& export _resty_host="$url"
	    ;;
	*)
	    resty "http://$url" "${@[@]}"
	    ;;
    esac
}



function resty-call() {
    # maybe: check # HEAD|OPTIONS|GET|DELETE|POST|PUT|PATCH|TRACE)

    local -a curlopt
    local -a curlopt2

    # TODO: local to reset
    local host="$_RESTY_DATA_DIR/host"
    local cookies="$_RESTY_DATA_DIR/c"

    local method="$1"; [[ $# > 0 ]] && shift
    local h2t=$((exec 2>&-; (which lynx >/dev/null && echo lynx -stdin -dump) \
			  || which html2text || which cat) |tail -n 1)
    local editor=$((exec 2>&-; which "$EDITOR" || which vim || echo "vi") |tail -n 1)         # editor default

    if [[ "POST PUT TRACE DELETE" =~ "$method" ]]; then local hasbody="yes" ;fi

    if [ -d "$cookies" ] ; then   # retrieve cookie
	(mkdir -p "$cookies"; echo "http://localhost*" > "$host")
    fi

    if [[ "$1"  =~ "^/" ]] ; then  # retrieve path
	local _path="$1"
	[[ $# > 0 ]] && shift
    fi
    if [[ ! "$1"  =~ "^-" ]] ; then  # retrieve  data
	local body="$1"
	[[ $# > 0 ]] && shift
    fi

    local raw query vimedit quote maybe_query verbose
    local j=1 # try to replace with happened?
    # TODO: use an option parser or a switch
    for opt in "$@"; do
	if [ -n "$maybe_query" -a -z "$query" ] ; then query="?$opt"; continue; fi

	case $opt in
	    --verbose|-v) verbose="yes";;
		# TODO; try adapt ; echo "$opt" | grep '^-[a-zA-Z]*v[a-zA-Z]*$' >/dev/null) \
	    -V) vimedit="yes" ;;
	    -Z) raw="yes" ;;
	    -W) ;; # §todo: check why nothing?
	    -Q) quote="yes" ;;
	    -q) maybe_query="yes" ;;
	    *) curlopt[j]="$opt" && j=$((j + 1))
	esac
	## idea: add --json, other option.
    done

    if [ -z "$quote" ]; then # replace special char with codes
	_path=$(echo "$_path"|sed 's/%/%25/g;s/\[/%5B/g;s/\]/%5D/g;s/|/%7C/g;s/\$/%24/g;s/&/%26/g;s/+/%2B/g;s/,/%2C/g;s/:/%3A/g;s/;/%3B/g;s/=/%3D/g;s/?/%3F/g;s/@/%40/g;s/ /%20/g;s/#/%23/g;s/{/%7B/g;s/}/%7D/g;s/\\/%5C/g;s/\^/%5E/g;s/~/%7E/g;s/`/%60/g')
    fi

    if [[ "HEAD OPTIONS" =~ "$method" ]] ; then raw="yes" ; fi
    if [ -z "$_resty_host" ] ;then local _resty_host=$(cat "$host" 2>/dev/null);fi

    if [ "$method" = "-v" ] ; then # ??
	echo "$_resty_host $_resty_opts"
	return
    fi
    if [ -z "$method" ] ; then # return since no method
	echo "$_resty_host"
	return
    fi
    if [ -n "$_path" ] ; then # .??
	local _resty_path=$_path
    fi

    local domain=$(echo -n "$_resty_host" \
		    |perl -ane '/^https?:\/\/([^\/\*]+)/; print $1')
    local _path="${_resty_host//\*/$_resty_path}"

    eval "curlopt2=(${_resty_opts[*]})"  # TODO: rename or change

    if [ "$hasbody" = "yes" ] && [ -z "$body" ]; then # treat the empty? body
	if [ ! -t 0 ] ; then # retrieve what stdin hold
	    body="@-"
	else
	    body=""
	fi
    fi

    if [ "$hasbody" = "yes" ] && [ "$vimedit" = "yes" ]; then
	loxal tmpf=$(mktemp /tmp/resty.XXXXXX)
	[ -t 0 ] || cat > $tmpf
	(exec < /dev/tty; "$editor" $tmpf)
	body=$(cat $tmpf)
	rm -f $tmpf
    fi

    if [ -n "$body" ] && [ "$body" != "@-" ] ; then [[ $# > 0 ]] && shift;fi
    if [ "$1" = "-Z" ] ; then  raw="yes" ; [[ $# > 0 ]] && shift ;fi
    if [ -n "$body" ] ;then curl_opt="--data-binary" ;fi
    if [ "$method" = "HEAD" ] ; then
	curl_opt="-I"
	raw="yes"
    fi


    if [ -f "$_RESTY_CONF_DIR/$domain" ] ; then  # Retrieve stored option in config dir.
	## §maybe: cache this when resty)
	local cmd="args2=( $(cat "$_RESTY_CONF_DIR/$domain" 2>/dev/null |sed 's/^ *//' |grep ^$method |cut -b $((${#method}+2))-) )"
	# echo $cmd
	eval $cmd
    fi

    # Launch command and retrieved streams
    local res out err ret
    res=$((((curl -sLv $curl_opt "$body" -X $method -b "$cookies/$domain" -c "$cookies/$domain" \
		     "${args2[@]}" "${curlopt2[@]}" "${curlopt[@]}" "$_path$query" \
				| sed 's/^/OUT /' && echo) 3>&2 2>&1 1>&3) |sed 's/^/ERR /' && echo) 2>&1)
    out=$(sed '/^OUT /s/^....//p; d' <<< "$res" )
    err=$(sed '/^ERR /s/^....//p; d' <<< "$res" )
    ret=$(sed '/^.*HTTP\/1\.[01] [0-9][0-9][0-9]/s/.*\([0-9]\)[0-9][0-9].*/\1/p; d' <<< "$err" | tail -n1)

    if [ -n "$err" -a -n "$verbose" ]; then echo "$err" 1>&2 ; fi

    if  grep -i '^< \s*Content-Type:  *text/html' >/dev/null <<< "$err" &&[ -z "$raw" ]
    then d=$h2t
    else d=cat
    fi
    # TODO: rename d to output tool

    if [ -n "$out" ]; then  out=$(echo "$out" | "$d") ; fi

    # §TODO: refactor
    [ "$d" != "${d##lynx}" ] && out=$(echo "$out" |perl -e "\$host='$(echo "$_resty_host" |sed 's/^\(https*:\/\/[^\/*]*\).*$/\1/')';" -e '@a=<>; $s=0; foreach (reverse(@a)) { if ($_ =~ /^References$/) { $s++; } unless ($s>0) { s/^\s+[0-9]+\. //; s/^file:\/\/localhost/$host/; } push(@ret,$_); } print(join("",reverse(@ret)))')

    if [ "$ret" != "2" ]; then
	[ -n "$out" ] && echo "$out" 1>&2
	return $ret
    else
	[ -n "$out" ] && echo "$out"
    fi

}

function HEAD() {
    resty-call HEAD "$@"
}

function OPTIONS() {
    resty-call OPTIONS "$@"
}

function GET() {
    resty-call GET "$@"
}

function POST() {
    resty-call POST "$@"
}

function PUT() {
    resty-call PUT "$@"
}

function PATCH() {
    resty-call PATCH "$@"
}

function DELETE() {
    resty-call DELETE "$@"
}

function TRACE() {
    resty-call TRACE "$@"
}

[ "$1" = "-W" ] && export _resty_nohistory="/dev/null" && [[ $# -gt 0 ]] && shift

resty "$@" >/dev/null 2>&1
